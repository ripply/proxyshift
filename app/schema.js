var string = 'string';
var increments = 'increments';
var integer = 'integer';
var cascade = 'cascade';
var setnull = 'set null';
var restrict = 'restrict';
var boolean = 'boolean';
// Fixtures library does not like timestamps in postgres for some reason
// https://github.com/city41/node-sql-fixtures/blob/master/lib/prioritize.js#L177
// so we are going to use UTC in a bitint as integer will only get us to 2038
var date = 'bigint';
var RAW = 'RAW';

// http://blog.ragingflame.co.za/2014/7/21/using-nodejs-with-mysql

var Function = {
    'shiftapplicationsonlyonenonrecinded(integer, integer)': {
        name: 'shiftapplicationsonlyonenonrecinded',
            up: 'function shiftapplicationsonlyonenonrecinded(shift_id integer, user_id integer) returns boolean as $$ ' +
        'select count(*) <= 1 from shiftapplications ' +
        'where shiftapplications.shift_id = shift_id ' +
        'and shiftapplications.user_id = user_id ' +
        'and (shiftapplications.recinded is null ' +
        'or shiftapplications.recinded = false); ' +
        '$$ language sql;',
            down: 'drop function if exists shiftapplicationsonlyonenonrecinded(integer, integer);'
    }
};

var Schema = {
    // Key values are Model names
    // table names are generated by
    // lower-casing
    // and pluralizing
    // Holds settings for users
    UserSetting: {
        comment: 'Holds user settings',
        id: {
            type: increments,
            index: {},
            comment: 'A Users settings'
        },
        pushnotifications: {
            type: boolean,
            index: {},
            comments: 'If true, user will receive push notifications',
            defaultTo: true
        },
        textnotifications: {
            type: boolean,
            index: {},
            comment: 'If true, user will receive text notifications',
            defaultTo: false
        },
        emailnotifications: {
            type: boolean,
            index: {},
            comment: 'If true, user will receive email notifications',
            defaultTo: false
        }
    },
    User: {
        id: {
            type: increments,
            index: {},
            nullable: false
        },
        usersetting_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'usersettings',
            onDelete: cascade,
            onUpdate: cascade,
            unique: true,
            comment: 'Links a user with their settings',
            nullable: false
        },
        username: {
            type: string,
            index: {},
            unique: true,
            nullable: false,
            // FIXME: Enabling this overwrites our password encryption on save event
            // lowercase: true,
            maxlen: 50
        },
        firstname: {
            type: string,
            nullable: false
        },
        lastname: {
            type: string,
            nullable: false
        },
        email: {
            type: string,
            index: {},
            unique: true,
            // lowercase: true,
            nullable: false
        },
        verified_email: {
            type: boolean,
            index: {},
            comment: 'True when the user verifies their email',
            default: false
        },
        password: {
            type: string,
            index: {},
            unique: false,
            maxlen: 100,
            nullable: false,
            encrypt: true
        },
        squestion: {
            type: string,
            nullable: false
        },
        sanswer: {
            type: string,
            nullable: false
        },
        phonehome: {
            type: string
        },
        phonemobile: {
            type: string,
            unique: false
        },
        pagernumber: {
            type: string
        }
    },
    // GMail OAuth tokens
    // refresh_token can only be obtained once upon OAuth
    // access_token will be updated occasionally and must be stored
    EmailAccessToken: {
        comment: 'GMail OAuth tokens refresh_token can only be obtained once upon OAuth access_token will be updated occasionally and must be stored',
        id: {
            type: increments,
            comment: 'GMail OAuth tokens'
        },
        account: {
            type: string,
            comment: 'GMail account to use with OAuth',
            nullable: false
        },
        refresh_token: {
            type: string,
            comment: 'GMail OAuth refresh token',
            nullable: false
        },
        access_token: {
            type: string,
            comment: 'GMail OAuth access token',
            nullable: false
        }
    },
    // Tokens for users to verify their emails
    EmailVerifyToken: {
        comment: 'Tokens for users to verify their emails',
        id: {
            type: increments,
            index: {},
            comment: 'Tokens for users to verify their emails'
        },
        user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            onDelete: cascade,
            onUpdate: cascade,
            unique: false,
            comment: 'User having their email verified',
            nullable: false
        },
        token: {
            type: string,
            index: {},
            comment: 'One time use email verification token',
            nullable: false
        },
        expires: {
            type: date,
            index: {},
            comment: 'When this token expires',
            nullable: false
        }
    },
    // Holds settings for groups
    GroupSetting: {
        comment: 'Holds settings for groups',
        id: {
            type: increments,
            index: {},
            comment: 'Holds settings for groups (A Company)'
        },
        allowalltocreateshifts: {
            type: boolean,
            index: {},
            comment: 'Any user can create a shift',
            defaultTo: false,
            nullable: false
        },
        requireshiftconfirmation: {
            type: boolean,
            index: {},
            comment: 'If true, will require manager approval',
            defaultTo: true,
            nullable: false
        }
    },
    Group: {
        id: {
            type: increments,
            index: {},
            comment: 'A Company with an account'
        },
        user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            onDelete: restrict,
            onUpdate: cascade,
            nullable: false
        },
        name: {
            type: string,
            index: {},
            nullable: false
        },
        state: {
            type: string,
            index: {}
        },
        city: {
            type: string,
            index: {}
        },
        address: {
            type: string,
            index: {}
        },
        zipcode: {
            type: integer, // TODO: this should be a string? zipcodes can have - in them
            index: {}
        },
        weburl: {
            type: string,
            index: {}
        },
        contactemail: {
            type: string,
            nullable: false
        },
        contactphone: {
            type: string
        },
        groupsetting_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'groupsettings',
            onDelete: cascade,
            onUpdate: cascade,
            unique: true,
            comment: 'Link to settings for the entire Company',
            nullable: false
        }
    },
    // groups can have different permissions
    // eg: unprivileged, privileged etc
    // here they can customize the name of their permission levels
    GroupPermission: {
        comment: 'groups can have different permissions eg: unprivileged, privileged etc here they can customize the name of their permission levels',
        id: {
            type: increments,
            index: {},
            comment: 'Companies can have variying levels of permissions, unprivileged, privileged etc'
        },
        groupsetting_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'groupsettings',
            onDelete: cascade,
            onUpdate: cascade,
            // comment: // TODO
            nullable: false
        },
        description: {
            type: string,
            nullable: false
        },
        permissionlevel: {
            // TODO: What is this table for? it doesnt link to a user or location
            type: integer,
            index: {},
            nullable: false
        },
        group_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'groups',
            onDelete: cascade,
            onUpdate: cascade,
            nulable: false
        }
    },
    // timezones for linking
    Timezone: {
        comment: 'timezones for linking',
        id: {
            type: increments,
            index: {}
        },
        name: {
            type: string,
            index: {},
            unique: true
        }
    },
    // physical store where things happen
    Location: {
        comment: 'physical store where things happen',
        id: {
            type: increments,
            index: {}
        },
        group_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'groups',
            onDelete: restrict, // prevent accidental deletion of a location
            onUpdate: cascade,
            nullable: false
        },
        timezone_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'timezones',
            onDelete: restrict,
            onUpdate: cascade,
            nullable: false
        },
        title: {
            type: string,
            nullable: false
        },
        state: {
            type: string,
            nullable: false
        },
        city: {
            type: string,
            nullable: false
        },
        address: {
            type: string,
            nullable: false
        },
        zipcode: {
            type: string,
            nullable: false
        },
        phonenumber: {
            type: string,
            nullable: false
        }
    },
    // area of a store, eg: floor
    SubLocation: {
        comment: 'area of a store, eg: floor',
        id: {
            type: increments,
            index: {}
        },
        title: {
            type: string,
            index: {},
            nullable: false,
            unique: false
        },
        description: {
            type: string,
            index: {},
            nullable: false,
            unique: false
        },
        location_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'locations',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: false
        }
    },
    // collection of locations
    // eg: District, state
    Area: {
        comment: 'collection of locations, not currently used much',
        id: {
            type: increments,
            index: {}
        },
        title: {
            type: string,
            index: {},
            nullable: false,
            // TODO: If we have one database for the entire site it doesn't make sense to have this be unique, each company can have identically named places
            unique: false
        },
        group_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'groups',
            onUpdate: cascade,
            onDelete: cascade
        }
    },
    // connects locations to an area
    AreaLocation: {
        comment: 'connections locations to an area',
        id: {
            type: increments,
            index: {}
        },
        location_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'locations',
            onUpdate: cascade,
            onDelete: cascade
        },
        area_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'areas',
            onUpdate: cascade,
            onDelete: cascade
        }
    },
    // job type that a user can be
    GroupUserClass: {
        comment: 'job type that a user can be',
        id: {
            type: increments,
            index: {}
        },
        group_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'groups',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: false
        },
        title: {
            type: string,
            maxlen: 50,
            nullable: false
        },
        description: {
            type: string,
            maxlen: 50
        },
        cansendnotification: {
            type: boolean,
            index: {},
            defaultTo: true,
            nullable: false
        },
        requiremanagerapproval: {
            type: boolean,
            index: {},
            defaultTo: true,
            nullable: false,
            comment: 'Indicates whether this job type requires manager approval'
        },
        grouppermission_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'grouppermissions',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: false,
            comment: 'How privileged is this job type'
        }
    },
    GroupCreationInvitation: {
        comment: 'Invite to create a group, holds tokens',
        id: {
            type: increments,
            index: {}
        },
        message: {
            type: string
        },
        email: {
            type: string,
            index: {},
            unique: false,
            nullable: false
        },
        expires: {
            type: date,
            index: {},
            nullable: false
        },
        token: {
            type: string,
            index: {},
            unique: true,
            nullable: false
        }
    },
    GroupInvitation: {
        comment: 'Invitation to a group from a user',
        id: {
            type: increments,
            index: {}
        },
        inviter_user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            onDelete: cascade,
            onUpdate: cascade,
            unique: false,
            nullable: false
        },
        // if invited person is already in the system
        user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            onDelete: cascade,
            onUpdate: cascade,
            unique: false,
            nullable: true
        },
        // invited person is not in the system
        email: {
            type: string,
            unique: false,
            nullable: true
        },
        grouppermission_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'grouppermissions',
            onDelete: cascade,
            onUpdate: cascade,
            unique: false,
            nullable: false
        },
        message: {
            type: string,
            nullable: true
        },
        expires: {
            type: date,
            index: {},
            nullable: false
        },
        token: {
            type: string,
            index: {},
            unique: true,
            nullable: false
        }
    },
    GroupInvitationUserClass: {
        comment: 'Userclass type that a user is invited as',
        id: {
            type: increments,
            index: {}
        },
        groupinvitation_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'groupinvitations',
            onDelete: cascade,
            onUpdate: cascade,
            unique: false,
            nullable: false
        },
        groupuserclass_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'groupuserclasses',
            onDelete: cascade,
            onUpdate: cascade,
            unique: false,
            nullable: false
        }
    },
    Shift: {
        id: {
            type: increments,
            index: {}
        },
        user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            onUpdate: cascade,
            onDelete: cascade,
        },
        /*
        title: {
            type: string,
            maxlen: 30,
            nullable: false
        },
        */
        description: {
            type: string,
            maxlen: 256
        },
        start: {
            type: date,
            index: {},
            nullable: false
        },
        end: {
            type: date,
            index: {},
            nullable: false,
            check: {
                'check(start < "end")': RAW
            }
        },
        timezone_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'timezones',
            onDelete: restrict,
            onUpdate: cascade,
            nullable: false
        },
        groupuserclass_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'groupuserclasses',
            onUpdate: cascade,
            onDelete: cascade
        },
        location_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'locations',
            unique: false,
            nullable: true,
            onUpdate: cascade,
            onDelete: cascade
        },
        sublocation_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'sublocations',
            unique: false,
            nullable: true,
            onUpdate: cascade,
            onDelete: cascade
        },
        notify: {
            type: date,
            index: {},
            nullable: true
        },
        // shift is canceled
        // it doesn't make sense to just out right delete a shift that was made
        // this provides no indication to any applicants or people interested that a shift has disappeared
        canceled: {
            type: boolean,
            index: {},
            default: false,
            nullable: false
        }
    },
    // Keeps a record of reasons that a shift has been canceled
    // each shift can have multiple reasons
    // this prevents an employee of initially putting a valid reason
    // then changing it after the fact
    ShiftCancelationReason: {
        comment: 'Keeps a record of reasons that a shift has been canceled, each shift can have multiple reasons this prevents an employee of initially putting a valid reason then changing it after the fact',
        id: {
            type: increments,
            index: {}
        },
        // reason for canceling a shift
        reason: {
            type: string,
            nullable: false
        },
        // user who canceled a shift
        user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            unique: false,
            nullable: false,
            onUpdate: cascade,
            onDelete: cascade
        },
        // shift that was canceled
        shift_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'shifts',
            unique: false,
            nullable: false,
            onUpdate: cascade,
            onDelete: cascade
        },
        // UTC second that shift was canceled
        date: {
            type: date,
            index: {},
            nullable: false
        }
    },
    // Application for a shift
    ShiftApplication: {
        comment: 'Application for a shift',
        id: {
            type: increments,
            index: {}
        },
        shift_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'shifts',
            onDelete: cascade
        },
        user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            onUpdate: cascade,
            // TODO: Should we delete this shift application?
            onDelete: cascade
        },
        date: {
            type: date,
            index: {},
            nullable: false
        },
        // application for shift has been recinded
        recinded: {
            type: boolean,
            index: {},
            default: false,
            nullable: false,
            comment: 'Shift application has been recinded',
            /*
            check: {
                'shiftapplicationsonlyonenonrecinded(integer, integer)': ['shift_id', 'user_id']
            }
            */
        },
        recindeddate: {
            type: date,
            index: {},
            nullable: true
        }
    },
    // Reason for recission of a shift application
    ShiftRescissionReason: {
        comment: 'Reason for recission of a shift application',
        id: {
            type: increments,
            index: {}
        },
        shiftapplication_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'shiftapplications',
            onDelete: cascade
        },
        user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            onDelete: cascade
        },
        date: {
            type: date,
            index: {},
            nullable: false
        },
        reason: {
            type: string,
            index: {},
            nullable: false
        }
    },
    ShiftApplicationAcceptDeclineReason: {
        comment: 'Links to a shift application and is what determins if the application is approved or denied',
        id: {
            type: increments,
            index: {}
        },
        accept: {
            type: boolean,
            index: {},
            nullable: false,
            comment: 'Is the shift application approved'
        },
        autoaccepted: {
            type: boolean,
            index: {},
            nullable: false,
            comment: 'System auto approved the shift because at time of creation, it did not require manager approval'
        },
        shiftapplication_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'shiftapplications',
            onDelete: cascade
        },
        user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            onDelete: cascade,
            nullable: true,
            comment: 'User who made the approval, it will be null if the system auto approved it'
        },
        date: {
            type: date,
            index: {},
            nullable: false,
            comment: 'Date the approval/denial was made'
        },
        reason: {
            type: string,
            nullable: true,
            comment: 'Reasons for denial of the shift application'
        }
    },
    IgnoreShift: {
        comment: 'Marks a shift as ignored for a user',
        id: {
            type: increments,
            index: {}
        },
        shift_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'shifts',
            onDelete: cascade
        },
        user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            onDelete: cascade
        }
    },
    // connects a user to a group
    UserGroup: {
        comment: 'Connects a user to a group',
        id: {
            type: increments,
            index: {}
        },
        user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            onUpdate: cascade,
            onDelete: cascade
        },
        group_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'groups',
            onUpdate: cascade,
            onDelete: cascade
        },
        grouppermission_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'grouppermissions',
            onUpdate: cascade,
            onDelete: restrict
        }
    },
    // remember me tokens
    Token: {
        comment: 'Remember me tokens',
        id: {
            type: increments,
            index: {}
        },
        user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: false
        },
        token: {
            type: string,
            index: {},
            nullable: false,
            unique: true
        },
        date: {
            type: date,
            index: {},
            nullable: false
        }
    },
    PushToken: {
        comment: 'Pushtokens for devices',
        id: {
            type: increments,
            index: {}
        },
        token_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'tokens',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: false
        },
        token: {
            type: string,
            index: {},
            nullable: false,
            unique: true
        },
        platform: {
            type: integer,
            index: {},
            nullable: false
        },
        date: {
            type: date,
            index: {},
            nullable: false
        },
        expires: {
            type: date,
            index: {},
            nullable: false
        }
    },
    // relates a user to a job type
    GroupUserClassToUser: {
        comment: 'Relates a user to a job type',
        id: {
            type: increments,
            index: {}
        },
        user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: false
        },
        groupuserclass_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'groupuserclasses',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: false
        }
    },
    // Links a user to a location or sublocation (permissions are linked via group job type instead of via this)
    UserPermission: {
        comment: 'Links a user to a location or sublocation (permissions are linked via group job type instead of via this)',
        id: {
            type: increments
        },
        location_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'locations',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: true
        },
        sublocation_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'sublocations',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: true
        },
        user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            onDelete: cascade,
            nullable: false
        },
        subscribed: {
            type: boolean,
            index: {},
            defaultTo: true,
            nullable: false
        }
    },
    // TODO: DESCRIBE THIS
    GroupAdditionalInformation: {
        id: {
            type: increments,
            index: {}
        },
        group_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'groups',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: false
        },
        title: {
            type: string,
            nullable: false
        }
    },
    // TODO: DESCRIBE THIS
    GroupUserInformation: {
        id: {
            type: increments,
            index: {}
        },
        user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: false
        },
        groupadditionalinformation_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'groupadditionalinformations',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: false
        },
        data: {
            type: string,
            nullable: false
        }
    },
    // TODO: This table needs to be culled when a users' permission is lowered
    ManagingClassesAtLocation: {
        id: {
            type: increments,
            index: {}
        },
        // userid of a privileged member
        usergroup_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'usergroups',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: false
        },
        // location that manager is managing at
        location_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'locations',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: false
        },
        // class that manager manages
        groupuserclass_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'groupuserclasses',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: false
        },
        // Lets us notify managers when a new class is added
        // if they want to manage that type of user
        managing: {
            type: boolean,
            index: {},
            defaultsTo: false,
            nullable: false
        }
    },
    ResetPasswordToken: {
        id: {
            type: increments,
            index: {}
        },
        user_id: {
            type: integer,
            index: {},
            references: 'id',
            inTable: 'users',
            onDelete: cascade,
            onUpdate: cascade,
            nullable: false,
            unique: true
        },
        token: {
            type: string,
            index: {},
            nullable: false,
            unique: true
        },
        expires: {
            type: date,
            index: {},
            nullable: false
        },
        lastEmailSent: {
            type: date,
            index: {},
            nullable: false
        }
    }
};

module.exports = {
    Schema: Schema,
    Function: Function
};
